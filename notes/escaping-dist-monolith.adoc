= Talk: How to Escape the Distributed Monolith by Ian Cooper
:id: 20210907114101

* *Temporal Coupling* = these services must be up at the same time
* Partition with Bounded Context & Capabilities
* often, monolith \-> microservices happens when team outgrows the "2 pizza team" size
* Question: What if you start with microservices?
* Request-driven architecture
 ** HTTP call, directly to dependent services
  *** \=> temporal coupling
  *** \=> lost revenue
* *Behavioral Coupling*
 ** if "DIRECT BOOKING" calls "HOUSEKEEPING" and Housekeeping is decomposed into CLEANING, LAUNDRY and INVENTORY, then Direct Booking has to be changed
* Solutions
 ** use proxy for availability
  *** proxy can handle retries, circuit breaker, etc.
  *** "service message" is essentially a Corba requet broker with a new name
* "Smart endpoints and dumb pipes"
 ** a _reliable_ distributed monolith is still a distributed monolith
* Consistent or Available: have to choose 1
* CAP Theorem
 ** Consistent
 ** Available
 ** Partition Tolerance
* Event Driven Architecture
 ** messaging over a light weight service bus
 ** cache reference data from other services
* *Conversations / sagas*
 ** e.g.
multiple steps to make a booking and each step can add data to the message, process credit card payments, etc.
 ** generally using some kind of state machine
* autonomous, communicate through interfaces
* "microservice" does not necessarily mean a single OS process
* `If-modified-since`, `etag`, etc.
to control caching
 ** *Inside data* vs *outside data*
  *** outside data can be stored in a cache as *Reference Data*
* *Reference data* is protocol agnostic
* *Event carried state transfer*
 ** services publish notifications about state changes of their data
 ** downstream services can consume these notifications to build their own cache
* _Hybrid_ approach - most real systems have a mix of requests and events
* with messages, you can do request/response
 ** just use  channels
 ** Request lists the reply channel in the header of the request
